# Building the docker image
To build the docker image, depending on platform, run the below command from the root of the project:
```
-- LINUX
docker build -t proximity:latest -f docker/Dockerfile --build-arg GROUP_ID=$(id -g) --build-arg USER_ID=$(id -u) .

-- WINDOWS or MAC
docker build -t proximity:latest -f docker/Dockerfile .
```

# Running the docker image via compose
Once it's done building, run the command below from the root of the project. Output of proximity will 
end up in a folder named `images`.
```
docker-compose -f docker/docker-compose.yml up
```

# Tweeking docker setup
This section aims to explain the different docker settings you can tinker with, as well as motivating some of
the design choices that's been made with regards to the docker files.

## Docker compose settings
The `docker-compose.yml` file controls what's going on once we run Proximity inside the docker container. 
There are a couple of defaults set to give a smooth user experience firs time around: We 
automatically mount and use the `cards.txt` file as the cardslist we'll generate, and we automatically 
mount the `run/templates` folder, and use the `normal` template for card generation. Lastly, we mount
the `images` folder as output target for the Proximity process.

### Change the cards list
The simplest solution is to just edit the content of the existing `cards.txt` file to whatever you want.
If that for some reason isn't an option, and you would like to use another file for cards, replace the path
of the file to mount as cardslist (What's left of the `:` in Volume 1. The path is relative to the 
docker-compose.yml file). 

### Change the template
If you would like to use another template, the easiest solution is to place it in the `run/tempaltes`
folder, and change `normal` in the `--template=normal` part of the run command to the name of the 
new template folder (or the zip file, if you opt for using a zip).

### Change the output folder
If you would like to change the output folder, replace the path of the mounted output folder.
(What's left of the `:` in Volume 1. The path is relative to the docker-compose.yml file). 

### Change command-line flags
If you want to add additional command line flags to pass to Proximity, the easiest is to just add them
at the end of the `run` command. A complete list of command-line flags that can be passed can be found
on the [wiki](https://github.com/Haven-King/Proximity/wiki).

## Running without compose
If you for some reason want to run the docker image without using compose, you will need to mount the 
various volumes manually, and pass the appropriate CLI flags. By default, the image is design to pass
the cli flags `--template=normal --cards=cardslist`, and uses `/app` as working directory. So the most
convenient is to mount your list of cards at `/app/cardslist` and your template at `/app/templates/normal`.
Then, you will also need to mount an output folder, to be able to extract the generated cards. Proximity
outputs cards in a folder called `images`, so you'll need to mount a folder at `/app/images` to be able
to extract them.

An example command to achieve all this would be the following. This command will run Proximity with the
all the default flags.
```
docker run -v $PWD/cards.txt:/app/cardslist -v $PWD/run/template/normal:/app/templates/normal -v $PWD/images:/app/images proximity:latest
```

If you want to provide your own set of flags, you will need to manually include the `--cards` and the 
`--template` flags in addition to whatever flags you wish. A

## File owners on Linus (aka. "Why --build-args on Linux")
Files generated inside a docker container is owned by whatever process is executing the docker process. On
Mac and Windows, the docker process is run by the current user process, so files generated by the docker
process is owned by the user. But on Linux, the docker process is normally run as the `root` user. This 
is normally not a problem, since docker isolates its file system inside the container. Proximity however
generates files that we want to access from outside the container (the output images), and thus, we mount
a directory to gain access to those files once they are generated. But since the files were generated by
the root user on Linux, normal users can't access these files.

Thus, we need a way for the docker process to generate files that can be accessed by the host user. There 
are two ways you can go about it: force-set the user running the container command (i.e. the `-u` flag) or 
creating a user when building the docker image with matching user- and group-id, and then setting that user
as the default user of the image. We've opted for the later, because then you are only required to pass the
user- and group-id when you build the image, and not everytime you run the image. The hope is that ut makes
for a slightly more convenient user experience. The drawback of this approach however is that the built
docker image cannot be shared between users, as the built image is locked to the user- and group-id of
whoever built the image. If we descide to one day publish pre-built docker images, we would need to  revisit
this design descision and instead set the user on each run command.
